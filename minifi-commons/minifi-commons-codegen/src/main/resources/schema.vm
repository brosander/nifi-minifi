/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package $class.package;

## Imports
#foreach($import in $class.classImports)import $import;
#end
##
## Calculate underscore and camel case names for each field
#set($underscoreNames = $util.newMap())
#set($camelCase = $util.newMap())
#set($underscoreNames[$class.wrapperName] = $util.calculateUnderscoreName($class.name))
#foreach($field in $class.fields)
    #set($underscoreNames[$field.name] = $util.calculateUnderscoreName($field.name))
    #set($camelCase[$field.name] = $util.camelCase($field.name))
#end

public#if(!$class.concrete) abstract#end class $schema.getActualClassname($class) extends BaseSchema #if($class.implementsString)implements $class.implementsString #end{
#foreach($field in $class.fields)
#if ($field.key)
    public static final String ${underscoreNames[$field.name]}_KEY = "$field.key";
#end
#end

#foreach($field in $class.fields)
#if ($field.hasDefault() || $field.required)
    public static final $field.type.declaration ${underscoreNames[$field.name]}_DEFAULT = #if($field.type.enum && $field.default)${field.type.name}.#end${schema.getDefaultLiteral($field)};
#end
#end

#if (!$class.wrapperName)
    private final String wrapperName;

#end
#foreach($field in $class.fields)
    private $field.type.declaration ${field.name}#if($field.hasDefault()) = ${underscoreNames[$field.name]}_DEFAULT#end;
#end

#if ($class.wrapperName)
    public ${schema.getActualClassname($class)}() {
#foreach($field in $class.fields)
#if ($class.isSchema($field.type.name))
        $field.name = new ${field.type.declaration}();
#end
#end
    }

    public ${schema.getActualClassname($class)}(Map map) {
#else
    public ${schema.getActualClassname($class)}(Map map, String wrapperName) {
        this.wrapperName = wrapperName;
#end
#foreach($field in $class.fields)
#if ($field.type.declaration.equals("int"))
#set($extraConvert = ".intValue()")
#elseif ($field.type.declaration.equals("long"))
#set($extraConvert = ".longValue()")
#else
#set($extraConvert = "")
#end
#if ($field.instantiator)
        $field.name = ${field.instantiator};
#elseif ($class.isSchema($field.type.name))
        $field.name = getMapAsType(map, ${underscoreNames[$field.name]}_KEY, ${field.type.mapType}.class, getWrapperName(), $field.required);
#elseif ($field.type.name.equals("List") && $class.isSchema($field.type.genericTypes.get(0).name))
        $field.name = convertListToType(getOptionalKeyAsType(map, ${underscoreNames[$field.name]}_KEY, ${field.type.mapType}.class, getWrapperName(), ${underscoreNames[$field.name]}_DEFAULT), ${underscoreNames[$field.name]}_KEY.toLowerCase().substring(0, ${underscoreNames[$field.name]}_KEY.length() - 1), ${field.type.genericTypes.get(0).mapType}.class, ${underscoreNames[$field.name]}_KEY);
#elseif ($field.type.enum)
#if ($field.hasDefault())
        String ${field.name}String = getOptionalKeyAsType(map, ${underscoreNames[$field.name]}_KEY, String.class, getWrapperName(), ${underscoreNames[$field.name]}_DEFAULT.name());
#elseif ($field.required)
        String ${field.name}String = getRequiredKeyAsType(map, ${underscoreNames[$field.name]}_KEY, String.class, getWrapperName());
#else
        String ${field.name}String = getOptionalKeyAsType(map, ${underscoreNames[$field.name]}_KEY, String.class, getWrapperName(), null);
#end
        if (${field.name}String != null) {
            try {
                $field.name = ${field.type.declaration}.valueOf(${field.name}String);
            } catch (IllegalArgumentException e) {
                addValidationIssue(${underscoreNames[$field.name]}_KEY, getWrapperName(), "it is not a valid ${field.type.declaration}");
            }
        }
#else
#if ($field.hasDefault() || $field.required)
        $field.name = getOptionalKeyAsType(map, ${underscoreNames[$field.name]}_KEY, ${field.type.mapType}.class, getWrapperName(), ${underscoreNames[$field.name]}_DEFAULT)$extraConvert;
#else
        $field.name = getOptionalKeyAsType(map, ${underscoreNames[$field.name]}_KEY, ${field.type.mapType}.class, getWrapperName())$extraConvert;
#end
#end
#end
        initValidation();
    }

    public void initValidation() {
#foreach($field in $class.fields)
#if (($class.isSchema($field.type.name)) || ($field.type.name.equals("List") && $class.isSchema($field.type.genericTypes.get(0).name)))
        addIssuesIfNotNull($field.name);
#end
#end
    }

    protected String getWrapperName() {
        return#if ($class.wrapperName) $schema.getWrapperNameCreator($class);
#else wrapperName
#foreach($field in $class.fields)
            .replace("{$field.name}", String.valueOf($field.name))#if (!$foreach.hasNext);#end

#end
#end
    }
#if ($class.writable && $class.fields.size() > 0)

    @Override
    public Map<String, Object> toMap() {
        Map<String, Object> result = mapSupplier.get();
#foreach($field in $class.fields)
#if ($field.toMap)
        $field.toMap
#elseif ($field.type.enum)
        if ($field.name != null) {
            result.put(${underscoreNames[$field.name]}_KEY, ${field.name}.name());
        }#if (!$field.omitIfEmpty) else {
            result.put(${underscoreNames[$field.name]}_KEY, "");
        }
#end
#elseif ($class.isSchema($field.type.name))
        putIfNotNull(result, ${underscoreNames[$field.name]}_KEY, $field.name);
#elseif ($field.type.name.equals("List") && $class.isSchema($field.type.genericTypes.get(0).name))
        putListIfNotNull(result, ${underscoreNames[$field.name]}_KEY, $field.name);
#elseif ($field.omitIfEmpty)
#if ($field.type.declaration.equals("String"))
        if (!StringUtil.isNullOrEmpty($field.name)) {
#else
        if ($field.name != null) {
#end
            result.put(${underscoreNames[$field.name]}_KEY, $field.name);
        }
#elseif (!$field.type.primitive && !$field.default)
        result.put(${underscoreNames[$field.name]}_KEY, $field.name == null ? "" : $field.name);
#else
        result.put(${underscoreNames[$field.name]}_KEY, $field.name);
#end
#end
        return result;
    }
#end
#foreach($field in $class.fields)

#if ($field.name.equals("id") && $field.type.declaration.equals("String"))
    @Override
#end
    public $field.type.declaration get${camelCase[$field.name]}() {
        return $field.name;
    }

    public void set${camelCase[$field.name]}($field.type.declaration $field.name) {
        this.$field.name = $field.name;
    }
#end

    @Override
    public List<String> getValidationIssues() {
        List<String> validationIssues = new ArrayList<>(super.getValidationIssues());
#foreach($field in $class.fields)
#if ($field.required && !$field.type.enum)
#if ($field.type.name.equals("String"))
        if (StringUtil.isNullOrEmpty($field.name)) {
#else
        if ($field.name == null) {
#end
            validationIssues.add(getIssueText(${underscoreNames[$field.name]}_KEY, getWrapperName(), IT_WAS_NOT_FOUND_AND_IT_IS_REQUIRED));
        }#if ($field.validator) else {
            String validation = ${field.validator}($field.name);
            if (validation != null) {
                validationIssues.add(getIssueText(${underscoreNames[$field.name]}_KEY, getWrapperName(), validation));
            }
        }
#else

#end
#elseif ($field.validator)
        String validation = ${field.validator}($field.name);
        if (validation != null) {
            validationIssues.add(getIssueText(${underscoreNames[$field.name]}_KEY, getWrapperName(), validation));
        }
#end
#end
        Collections.sort(validationIssues);
        return validationIssues;
    }
}
